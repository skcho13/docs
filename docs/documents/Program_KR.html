<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2025 서울 기계학습 철학 워크숍 – Translate Docs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../extracted/Probably Overthinking It.html" rel="next">
<link href="../documents/Program.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-3e062e8fe420344c07f1e837915f9541.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-55b2b16ef464b1d24caa77f57887db60.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-aeea4e2781fea0fa87091c4b8120fd0c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-9a906db709ed07d4d5e93d578d1cfe1b.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="2025 서울 기계학습 철학 워크숍 – Translate Docs">
<meta property="og:description" content="Translate Documents">
<meta property="og:site_name" content="Translate Docs">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title">2025 서울 기계학습 철학 워크숍</h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Translate Docs</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Documents</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Jack_Martin10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Reinterpreting Internalization and Agency through G.H. Mead’s Perspectival Realism</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/On_the_material_supports_of_subjectivity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">On the material supports of subjectivity</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/Program.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2025 Seoul Workshop on Philosophy of Machine Learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/Program_KR.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2025 서울 기계학습 철학 워크숍</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Probably Overthinking It.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PROBABLY OVERTHINKING IT</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/The Book of Why - Judea Pearl.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The book of why</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/nun_study.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Positive Emotions in Early Life and Longevity - Findings from the Nun Study</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Counterfactuals and Causal Inference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">COUNTERFACTUALS AND CAUSAL INFERENCE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Sobel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DISCUSSION - ‘THE SCIENTIFIC MODEL OF CAUSALITY’</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Causal inference in statistics An overview2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Causal inference in statistics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../extracted/Causal Inference in the Social and Behavioral Sciences2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Chapter 1 Causal Inference in the Social and Behavioral Sciences</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#초록" id="toc-초록" class="nav-link active" data-scroll-target="#초록">초록</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">2025 서울 기계학습 철학 워크숍</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Translated by Claude</p>
<p><strong>1일차 (2월 25일)</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 64%">
</colgroup>
<thead>
<tr class="header">
<th><strong>시간</strong></th>
<th><strong>행사</strong></th>
<th><strong>발표자</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>09:30-10:00</strong></td>
<td><strong>등록</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>10:00-10:10</strong></td>
<td><strong>개회식</strong></td>
<td><strong>환영사</strong> 정성규 (서울대학교 IDIS 원장)<strong>개회사</strong> <br> 전현득 (서울대학교)</td>
</tr>
<tr class="odd">
<td><strong>10:10-11:00</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk1">초청 강연 1</a></strong></td>
<td><strong>AI의 발전으로 과학을 재정의할 수 있을까?</strong><br> 고인석 (인하대학교)</td>
</tr>
<tr class="even">
<td><strong>11:00-11:10</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>11:10-12:00</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk2">초청 강연 2</a></strong></td>
<td><strong>예측적으로 유효한 “외계인적” 특성인가, 인공물인가? 이해불가능한 과학적 진보에 대처하기</strong><br> 카메론 버크너 (플로리다 대학교)</td>
</tr>
<tr class="even">
<td><strong>12:00-13:30</strong></td>
<td><strong>점심</strong></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>13:30-14:50</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#CT1">일반 발표 1</a></strong></td>
<td><strong>도구 그 이상: 코딩 AI와의 협업이 인지, 행위성, 그리고 주관성을 재형성하는 방식</strong> 권유빈 (서울대학교)<strong>분산적이고 확률적인 표상 모델</strong><br> 최이선 (이화여자대학교)</td>
</tr>
<tr class="even">
<td><strong>14:50-15:10</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>15:10-16:00</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk3">초청 강연 3</a></strong></td>
<td><strong>전체론자를 위한 고립주의</strong> 앙드레 커티스-트루델 (신시내티 대학교) 에밀리 설리반 (유트레히트 대학교)</td>
</tr>
<tr class="even">
<td><strong>16:00-16:10</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>16:10-18:10</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#CT2">일반 발표 2</a></strong></td>
<td><strong>인공적 가능성</strong> 보야나 그루지치치 (막스 플랑크 인지 스쿨) <strong>증강된.지성: 과학적 이해에서 확장된 마음으로서의 AI</strong> 우인진 (성균관대학교)<strong>자율무기체계와 정의로운 전쟁 이론: <em>정전론(Jus in Bello)</em> 원칙에 대한 비판적 재평가</strong><br> 김상수 (육군사관학교)</td>
</tr>
</tbody>
</table>
<p><strong>2일차 (2월 26일)</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 64%">
</colgroup>
<thead>
<tr class="header">
<th><strong>시간</strong></th>
<th><strong>행사</strong></th>
<th><strong>발표자</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>09:30-09:40</strong></td>
<td><strong>등록</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>09:40-10:30</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk4">초청 강연 4</a></strong></td>
<td><strong>AI와 과학적 발견의 논리</strong><br> 여연경 (동덕여자대학교)</td>
</tr>
<tr class="odd">
<td><strong>10:30-10:40</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>10:40-12:00</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#CT3">일반 발표 3</a></strong></td>
<td><strong>예측, 투영, 그리고 수행성</strong> 콘스탄틴 제닌 (튀빙겐 대학교) <strong>블랙 스완 이벤트 예측하기: 머신러닝의 최종 개척지?</strong><br> 허원기 (서울대학교)</td>
</tr>
<tr class="odd">
<td><strong>12:00-13:30</strong></td>
<td><strong>점심</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>13:30-14:20</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk5">초청 강연 5</a></strong></td>
<td><strong>찾고 있(지 않)는 것을 발견하기: AI 주도 발견의 전망과 도전</strong><br> 앙드레 커티스-트루델 (신시내티 대학교)</td>
</tr>
<tr class="odd">
<td><strong>14:20-14:30</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>14:30-15:20</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk6">초청 강연 6</a></strong></td>
<td><strong>설명 가능한 AI의 도덕적 중요성</strong><br> 케이트 브레덴버그 (런던 정치경제대학)</td>
</tr>
<tr class="odd">
<td><strong>15:20-15:40</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>15:40-16:30</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#InvitedTalk7">초청 강연 7</a></strong></td>
<td><strong>의료분야의 파운데이션 모델은 신뢰성에 대한 재고를 요구한다</strong><br> 토마스 그로테 (튀빙겐 대학교)</td>
</tr>
<tr class="odd">
<td><strong>16:30-16:40</strong></td>
<td><strong>휴식</strong></td>
<td></td>
</tr>
<tr class="even">
<td><strong>16:40-18:00</strong></td>
<td><strong><a href="https://25swpml.wordpress.com/program/#CT4">일반 발표 4</a></strong></td>
<td><strong>불투명성을 넘어서: ML 모델 이해에 있어 구현 세부사항이 중요한 이유</strong> 이형석 (서울대학교)<strong>AI는 과학적 지식의 경로가 될 수 있는가?</strong> 니콜라이 장 리 린딩 페더슨 (연세대학교) 옌스 크리스티안 비예링 (오르후스 대학교)</td>
</tr>
<tr class="odd">
<td><strong>18:00-18:10</strong></td>
<td><strong>폐회</strong></td>
<td></td>
</tr>
</tbody>
</table>
<section id="초록" class="level1">
<h1>초록</h1>
<p><strong>초청 강연 1</strong></p>
<p><strong>AI의 발전으로 과학을 재정의할 수 있을까?</strong></p>
<p>고인석 (인하대학교)</p>
<p>T. S. 쿤에 따르면, 과학은 전문화된 연구 영역에서 아직 해결되지 않은 퍼즐을 해결하는 집단적 활동이며, 이 활동은 구체적인 문제 해결의 하나 이상의 모범적인 사례에 의해 안내됩니다. 오늘날, AI가 필수적인 도구로 활용되는 과학 연구 사례가 점점 더 많아지고 있습니다. AI 에이전트들은 퍼즐을 해결하려는 주관적 동기를 가지고 있지 않지만, 쿤적인 방식으로 일부 퍼즐을 해결하거나, 적어도 (인간) 과학자들이 그렇게 할 수 있도록 도와주는 강력한 행위자로 등장할 것입니다. 이는 과학, 과학자, 그리고 과학적 연구의 개념이 변화할 것임을 시사합니다. AI의 발전이 우리로 하여금 과학을 재정의하도록 이끌 것인가? 저는 이 질문을 여러 관점에서 논의할 것입니다.</p>
<p><strong>초청 강연 2</strong></p>
<p><strong>예측적으로 유효한 “외계인적” 특성인가, 인공물인가? 이해불가능한 과학적 진보에 대처하기</strong></p>
<p>카메론 버크너 (플로리다 대학교)</p>
<p>AlphaFold와 같은 시스템은 많은 과학적 분석 영역에서 수작업으로 설계된 분석 모델의 이전 성능 상한선을 훨씬 뛰어넘는 예측적 AI 시스템의 전망을 제시합니다. 인간의 과학적 이론이 해결하기에 너무 복잡하거나 혼란스럽다고 여겨졌던 문제에서 예측 정확도를 달성할 수 있는 이러한 시스템의 결과에 동의하지 않기는 어렵습니다. 그러나 이러한 모델들은 어떤 면에서는 인간의 인지적 이해를 넘어서는 특성에 기반하여 예측할 수 있습니다 - 예측적 유용성은 있지만 우리에게 자연스럽거나 인지적으로 접근 가능하지 않은 “외계인적” 속성들입니다. 이 강연에서는 적대적 공격(adversarial attacks)에 대한 논의로 시작하여 이러한 특성들을 분석하고, 데이터 분석을 위해 점점 더 복잡한 딥러닝 모델에 의존하는 과학적 체제에서 이러한 인식론적 상황에 대처하는 방법을 논의할 것입니다.</p>
<p><strong>초청 강연 3</strong></p>
<p><strong>전체론자를 위한 고립주의</strong></p>
<p>앙드레 커티스-트루델 (신시내티 대학교)</p>
<p>에밀리 설리반 (유트레히트 대학교)</p>
<p>모델은 종종 그들의 대상 현상을 이상화합니다. 그러나 언제 이상화가 성공적이며 어떻게 이상화를 평가할 수 있을까요? 전체론자들은 모델과 그 이상화를 정당화하고 평가하는 것이 전체론적으로 진행되어야 하며 모델의 개별 부분을 집계하거나 평가하는 기능이 될 수 없다고 주장합니다. 전체론적 주장은, 다양한 압력점에서 발생합니다. 일부 매우 복잡한 모델의 경우, 불투명성과 모델의 다른 부분들 간의 상호작용의 복잡성으로 인해 모델 실패가 어디서 발생하는지 실질적으로 분리하기가 어렵습니다. 다른 경우에는, 고립주의가 더 근본적인 문제를 겪는 것으로 보입니다: 이상화는 모델 자체의 특성을 근본적으로 변경하지 않고는 제거하거나 분리할 수 없습니다. 이 강연에서는 머신러닝에서 매우 복잡한 모델인 AlphaFold의 예를 살펴봅니다. AlphaFold는 전체론적 프로젝트에 적합한 일종의 매우 복잡한 모델의 전형적인 예입니다. 그러나 우리는 AlphaFold의 이상화를 평가하고 그것이 성공에 기여하는 방식을 평가하기 위해 분해와 고립주의가 필요하며(실제로 가능하다고) 주장합니다. 결과적으로, 우리는 전체론자들이 고립주의적 프로젝트를 지지해야 한다고 주장합니다.</p>
<p><strong>초청 강연 4</strong></p>
<p><strong>AI와 과학적 발견의 논리</strong></p>
<p>여연경 (동덕여자대학교)</p>
<p>딥러닝 AI는 신뢰할 수 있는가? 정확한 단백질 구조 예측으로 유명한 딥러닝 AI인 AlphaFold2는 2024년 노벨 화학상을 수상했습니다. 그 경험적 성공은 분명히 인상적입니다. 그러나 많은 철학자들은 여전히 그것의 인식론적 불투명성에 대해 우려하고 있습니다. 다른 딥러닝 모델과 마찬가지로, AlphaFold2는 “블랙박스”로 작동하는데, 이는 내부 의사결정 과정이 완전히 해석 가능하지 않다는 것을 의미합니다. 이러한 투명성 부족은 근본적인 질문을 제기합니다: 언제 딥러닝 AI를 신뢰해야 하고, 언제 그렇지 않아야 하는가? 딥러닝 AI가 신뢰할 수 있다고 간주되기 위해 충족해야 하는 조건은 무엇인가? 과학적 지식이 딥러닝 AI만으로 도출될 수 있는가? 철학자들은 이러한 우려에 대해 광범위하게 논의해 왔으며, AlphaFold2와 AlphaFold3의 획기적인 성공으로 새로운 질문을 제기할 때입니다: 그들의 경험적 성과가 AlphaFold와 딥러닝 AI에 대한 철학자들의 회의적이거나 비관적인 견해에 도전할 수 있는가?</p>
<p>Duede(2023)는 딥러닝 AI가 타당한 가설을 생성하는 발견의 맥락에서는 가치가 있을 수 있지만, 과학적 주장이 엄격한 테스트와 확인을 필요로 하는 정당화의 맥락에서는 그렇지 않을 수 있다고 제안합니다. 그러나 이 오래된 구분이 딥러닝 AI를 옹호하는 유일한 방법인가요? AlphaFold2와 같은 인식론적으로 불투명한 시스템이 궁극적으로 신뢰할 수 없다고 결론지어야 하는가?</p>
<p>Ortmann(2025)은 why-reliability와 whether-reliability를 구분함으로써 이러한 회의론에 도전합니다. 그는 우리가 AlphaFold2가 왜 신뢰할 수 있는지 완전히 이해하지 못하더라도, 여전히 그것이 신뢰할 수 있는지 여부를 판단할 수 있다고 주장합니다. AlphaFold2의 whether-reliability는 이미 그것의 경험적 성공을 통해 입증되었습니다. 더욱이, 현대 과학 연구에서의 광범위한 채택은 그것의 whether-reliability에 대한 추가적인 지지를 제공합니다. 결국, 신뢰할 수 없는 도구는 과학적 실천에서 그렇게 광범위하게 사용되지 않을 것입니다.</p>
<p>그러나, 많은 회의적인 철학자들은 여전히 설득되지 않을 것입니다. 예를 들어, Duede(2022)는 단순한 귀납적 고려사항만으로는 충분하지 않으며, 투명성이 진정한 신뢰성에 필수적이라고 주장합니다. 마찬가지로, Mitchell(2020)은 신뢰성이 이론의 인식론적 보증과 지지 증거의 안정성의 조합에서 발생하기 때문에, 경험적 성공은 인식론적 보증을 동반해야 한다고 주장합니다.</p>
<p>이 발표는 Duede와 Mitchell에 대한 응답으로, 문제 해결 휴리스틱 집합으로 이해되는 발견의 논리가 AlphaFold와 딥러닝 AI에 필요한 인식론적 보증을 제공할 수 있는지 탐구합니다. 이 아이디어는 AlphaFold 개발의 기초가 되는 방법과 원칙이 그것의 why-reliability를 확립하기 위한 기초로 기능할 수 있다는 것입니다. AlphaFold의 창조를 이끈 휴리스틱을 명시함으로써, 우리는 AlphaFold와 딥러닝 AI에 요구되는 투명성에 대한 우려를 해결하기 위한 충분한 인식론적 보증을 제공할 수 있을지도 모릅니다.</p>
<p><strong>초청 강연 5</strong></p>
<p><strong>찾고 있(지 않)는 것을 발견하기: AI 주도 발견의 전망과 도전</strong></p>
<p>앙드레 커티스-트루델 (신시내티 대학교)</p>
<p>머신러닝(ML), 특히 딥러닝(DL) 시스템에 의한 최근의 중요한 과학적 성과는 자동화된 과학적 발견을 위한 ML에 대한 관심을 재활성화했습니다(예: Wang 외, 2023). 이러한 작업의 많은 부분은 DL 방법이 전통적인 이론 중심의 발견 접근법보다 더 효율적으로 현상, 가설, 심지어 모델이나 이론의 발견을 촉진할 수 있다는 생각에 의해 동기 부여됩니다. 이 강연은 최첨단 과학에서 자동화된, DL 주도 발견에 대한 더 구체적인 장애물 중 일부를 고려하며, 대표적인 사례 연구로 중력파 천체물리학(GWA)에 초점을 맞춥니다. 강연의 첫 번째 부분에서, 우리는 이러한 노력에도 불구하고 GWA에서 DL 주도 발견의 전망이 여전히 불확실하다고 주장합니다. 두 번째 부분에서, 우리는 DL이 기존의 발견 방법을 증강하거나 향상시키는 데 사용될 수 있는 방법과, 이러한 사용과 관련된 인식론적 미덕과 악덕에 대한 관심의 전환을 지지합니다. 우리는 이러한 많은 사용의 주요 인식론적 미덕이 퍼즐이나 이상 신호를 조사하는 것과 관련된 기회 비용을 감소시키는 것이며, 이러한 사용을 평가하기 위한 올바른 프레임워크는 추구가치성(pursuitworthiness)에 관한 철학적 작업에서 나온다고 주장합니다.</p>
<p><strong>초청 강연 6</strong></p>
<p><strong>설명 가능한 AI의 도덕적 중요성</strong></p>
<p>케이트 브레덴버그 (런던 정치경제대학)</p>
<p>AI 시스템을 이해하는 것은 인식론적으로뿐만 아니라 도덕적으로도 중요합니다. 이 강연에서, 저는 세 가지를 할 것입니다. 첫째, 우리가 예측 기계와 에이전트라고 부를 수 있는 두 가지 다른 유형의 AI 시스템에 대해 중요한 도덕적 가치에 대한 설명을 주장할 것입니다. 저는 예측 기계의 경우 정보에 입각한 자기 옹호를 가능하게 하는 것이 중요하며, 에이전트의 경우 신뢰와 대인 존중과 같은 가치가 중요하다고 주장합니다. 따라서 AI 시스템의 유형은 우리가 어떤 종류의 설명을 목표로 해야 하는지, 그리고 XAI에서의 상응하는 과학적 패러다임에 대한 영향을 미칩니다. 둘째, 예측 기계의 경우, 저는 신용 평가의 예를 사용하여 어떤 속성 P를 가진 사람이 되는 방법과 어떤 속성 P를 가진 사람으로 판단받는 방법을 설명하는 것 사이에 근본적인 긴장이 있다고 주장할 것입니다. 정적 모델링 선택과 불확실성 때문에, 둘은 분리됩니다. 후자는 수학적 관점에서 매력적이지만, 개인에 대한 실수 비용을 줄이는 배경 기관이 필요합니다. 그러나 전자는 정보에 입각한 자기 옹호를 적절히 가능하게 하지 않을 수 있습니다. 셋째, 저는 대인 간 정당화가 인공 에이전트를 포함한 에이전트에게 중요하지만, 정당화를 제공하기 위해서는 인공 에이전트가 부족한 이유와 사회적 규범에 대한 응답성이 필요하다고 주장할 것입니다.</p>
<p><strong>초청 강연 7</strong></p>
<p><strong>의료분야의 파운데이션 모델은 신뢰성에 대한 재고를 요구한다</strong></p>
<p>토마스 그로테 (튀빙겐 대학교)</p>
<p>파운데이션 모델이라고 불리는 새로운 종류의 AI 모델이 의료 분야에 진입했습니다. 파운데이션 모델은 신뢰성을 평가하기 위한 표준 머신러닝 패러다임의 몇 가지 기본 원칙을 위반합니다 - 그들은 훈련 중에 보았을 수 있는 데이터로 테스트되고, 다양하고 종종 불투명한 출처의 데이터로 훈련되며, 목적에 대한 적합성을 평가하기 어려운 출력을 생성합니다. 이러한 위반은 파운데이션 모델에 대한 보증된 신뢰를 확립하기 위해 우리가 어떤 보증을 요구하는지 재고할 필요가 있게 만듭니다.</p>
<p><strong>일반 발표 1</strong></p>
<p><strong>도구 그 이상: 코딩 AI와의 협업이 인지, 행위성, 그리고 주관성을 재형성하는 방식</strong></p>
<p>권유빈 (서울대학교)</p>
<p>AI와 함께 일한다는 것은, 무엇을 의미하는가? 효과적인 협업을 위해 어떤 변화가 필요한가? AI와의 협업이 인지, 행위성, 주관성에 대한 우리의 이해를 어떻게 재형성하는가?</p>
<p>AI는 학습, 문제 해결, 자율적 의사 결정과 같은 전통적으로 인간 인지와 관련된 기능을 수행할 수 있는 능력에서 이전 기술과 구별됩니다. OpenAI의 ChatGPT 출시 이후, 다양한 부문의 직장들은 생성형 AI를 워크플로우에 통합하고 인간-AI 팀을 관리하는 방법에 대한 중요한 질문을 불러일으키며 통합하는 방법을 탐색해 왔습니다.</p>
<p>소프트웨어 개발 커뮤니티에서, GitHub Copilot과 같은 코딩 AI 도구들은 빠르게 인기를 얻어 개발자들의 관행에 필수적이 되었습니다. 이 발표는 GitHub Copilot, Code Whisperer, Claude, ChatGPT를 포함한 코딩 AI를 정기적으로 사용하는 30명의 개발자들과의 심층 인터뷰와 그들의 워크플로우에 대한 관찰 연구에 기반합니다. 개발자들은 AI를 단순히 도구로 사용하는 것을 넘어서 - 그들은 AI를 조수, 파트너, 때로는 자신의 확장으로 대우합니다. 주목할 만하게, 개발자들은 의도와 목표를 AI에 적극적으로 “가르치고”, 반복적인 상호작용과 피드백을 통해 점차적으로 AI를 그들의 ’디지털 분신’으로 형성합니다. 이는 개발자들이 단순히 AI에 작업을 위임하는 것이 아니라 - 자신의 사고 과정을 AI와 공유하고 있음을 보여줍니다.</p>
<p>인지 및 인간-기계 인터페이스 프레임워크를 사용하여, 이 발표는 인간과 비인간 행위성 모두의 역할을 강조하며 인간-AI 협업에서 행위성의 역동적인 전개를 탐구합니다. 분산 인지와 인지적 조립체와 같은 프레임워크는 이러한 상호작용에서 인지 과정이 어떻게 재분배되고 재구성되는지 조명합니다. 개발자들은 점점 더 AI를 단순한 도구가 아니라 자신의 인지 과정의 확장으로 보게 되어, 인지적 조립체라고 부를 수 있는 것이 됩니다. 인간 개발자와 코딩 AI 사이의 상호작용 분석을 통해, 이 발표는 AI와의 일상적인 상호작용에서 인지와 행위성의 복잡한 얽힘을 반영하는 확장된 주관성 개념의 필요성을 보여줍니다.</p>
<p><strong>분산적이고 확률적인 표상 모델</strong></p>
<p>최이선 (이화여자대학교)</p>
<p>세계의 표상은 어떻게 구성되는가? 대략적으로 말하자면, 표상 시스템은 외부 소스로부터 데이터를 받아, 입력 시스템을 통해 그것을 인코딩하고, 내부 시스템에서 이 인코딩된 정보를 결합하여 작업 메모리에 전달하고 유지합니다. 우리의 세계 표상은 가필드, 톰, 체셔와 같은 개별 엔티티에 대한 정보뿐만 아니라 고양이와 같은 범주에 대한 표상도 포함합니다. 이러한 범주를 개념이라고 합니다. 우리는 개념을 사용하여 세계를 표상합니다.</p>
<p>인공지능에서의 표상 시스템에 관한 연구는 크게 두 과정으로 나눌 수 있습니다. 첫 번째는 개념 적용 과정으로, 새롭게 제공된 정보가 기존 개념적 프레임워크 내에서 어떻게 분류되는지 설명합니다. 두 번째는 개념 형성 과정으로, 데이터를 기반으로 새로운 개념이 어떻게 생성되는지 설명합니다. 이 연구는 후자에 초점을 맞추어, 개념 형성을 통해 세계 표상이 어떻게 결정되는지 논의합니다.</p>
<p>이 연구는 인공지능과 인지과학의 두 가지 주요 이론인 분산 표상(distributed representation)과 확률적 표상(probabilistic representation)을 통합하는 새로운 표상 이론을 제안합니다. 딥러닝의 핵심 이론인 분산 표상, 특히 자연어 처리와 컴퓨터 비전에서는 여러 차원으로 구성된 특징 공간에 데이터를 배치합니다. 예를 들어, 고양이 이미지는 윤곽, 모서리, 색상, 질감과 같은 저수준 특징을 추출하여 표현되고, 이것은 “귀를 가짐” 또는 “꼬리를 가짐”과 같은 더 복잡한 특징으로 결합됩니다. 이 특징 공간은 고차원 좌표계로 볼 수 있으며, 각 특징은 축으로 작용하고, 입력 데이터는 이 공간에서 단일 점 또는 벡터로 표현됩니다. 하나의 점은 다양한 특징의 조합으로 이해될 수 있습니다.</p>
<p>반면에, 확률적 표상 모델은 개념 형성 과정을 특정 우도 함수를 사용하여 특징 공간에서 데이터 클러스터를 분석하는 것으로 해석합니다. 밀집된 데이터 클러스터, 특히 다른 클러스터와 분리된 클러스터는 단일 개념으로 개별화될 가능성이 더 높습니다. 반대로, 희소한 클러스터나 여러 클러스터가 있는 패턴은 여러 개념으로 해석될 가능성이 더 높습니다. 이 모델은 “신의 관점”과 같은 특권적인 세계 표상이 존재하지 않는다고 가정하고, 동일한 데이터를 기반으로 다양한 관찰자가 동등한 세계 표상을 구성할 가능성을 열어줍니다. 이는 인간 표상의 특성과 일치하며 새로운 개념의 출현 조건도 설정합니다.</p>
<p>그러나 다른 세계 표상 모델이 존재한다면, 그것들은 서로 번역 가능해야 합니다. 그렇지 않으면 각 모델은 고립적으로 유아론적인 위험이 있습니다. 이 연구는 Kullback-Leibler 발산에 기반한 정량적 지표를 사용하여 서로 다른 특징 공간에서 개념의 일치도를 평가하고, 개념 간의 일관성과 차이를 평가하는 방법을 제안합니다.</p>
<p>그럼에도 불구하고, 분산 표상과 확률적 표상의 통합에는 몇 가지 제한이 따릅니다. 예를 들어, 특징 공간의 구성 - 어떤 특징과 얼마나 많은 특징이 포함되는지 - 은 동일한 외부 입력 데이터에 대해 완전히 다른 클러스터로 이어질 수 있습니다. 이러한 불일치는 모델 간에 개념 기반 클러스터를 번역하는 것을 어렵게 만들고, 모든 세계 표상 모델이 특징 공간의 동일한 차원 구조를 공유한다고 가정하는 것의 제약을 강조합니다. 이 연구는 이러한 제한이 표상 모델 설계에 미치는 영향을 탐구하고 통합된 표상 이론의 가능성과 경계를 조사합니다.</p>
<p><strong>일반 발표 2</strong></p>
<p><strong>인공적 가능성</strong></p>
<p>보야나 그루지치치 (막스 플랑크 인지 스쿨)</p>
<p>과학은 종종 사고 실험과 모델링을 통해 가능성, 우연성, 필연성과 관련된 문제를 다룹니다. 이 발표는 인지 과학에서 딥 뉴럴 네트워크를 사용함으로써 얼마나 많은 양식적 과학적 이해를 얻을 수 있는지 논의합니다. 신경망의 인식론적으로 유용한 특징 중 하나는 실행 가능성입니다 - 신경망은 인지적 작업을 수행하도록 훈련될 수 있으며, 새로운 자극이 주어졌을 때 실행될 수 있어 귀납적 편향 집합에 기반한 인지 현상의 가능성을 보여줍니다. 저는 가능성에 대한 신경망 기반 추론의 정당화 문제에 초점을 맞추고 타당한 정당화 전략을 개략적으로 설명합니다. 저는 신경망이 보여주는 가능성을 생물학적 가능성이 아닌 기술적 가능성으로 간주하는 여러 이유를 고려합니다. 그럼에도 불구하고, 저는 그것들이 인지 현상에 대한 우리의 양식적 과학적 이해에 기여한다고 주장합니다.</p>
<p><strong>증강된 지성: 과학적 이해에서 확장된 마음으로서의 AI</strong></p>
<p>우인진 (성균관대학교)</p>
<p>이 논문에서, 저는 인공지능(AI)이 (사회적으로) 확장된 인지의 메커니즘을 통해 과학적 이해를 발전시킨다고 주장합니다. 많은 연구자들은 AI가 AGI에 도달하면 의도성과 자율성과 같은 행위자성의 특정 조건을 만족시킬 수 있다고 추측합니다. 확장된 인지의 개념적 프레임워크를 검토하고 Pritchard와 Khalifa의 인식론적 관점을 통합함으로써, 저는 AI가 어떻게 전통적인 도구 기반 인지를 초월하여 과학적 이해의 적극적인 참여자가 되는지 보여드립니다.</p>
<p>AI는 Chalmers와 Clark(1998)이 정의한 대로 확장된 인지로 간주될 수 있습니다. 확장된 인지는 인간의 인지 과정을 외부 환경이나 도구와 통합하는 것을 포함합니다. 세 가지 필수 조건이 충족되어야 합니다: 신뢰할 수 있는 결합, 직접적인 가용성, 자동적인 승인입니다. AI는 일관되고 신뢰할 수 있게 작동하면서 인간 생활에 깊이 통합되어 있습니다(예: AI 비서). AI는 질문이나 명령에 즉시 응답하여 실시간으로 인간의 인지적 요구를 지원합니다. AI 시스템은 반복적인 사용과 긍정적인 경험을 통해 사용자의 신뢰를 얻습니다. 스마트폰이 초기 기술적 한계에도 불구하고 확장된 인지로 기능할 수 있는 잠재력을 보여준 것처럼, AI 또한 확장된 인지를 구성할 잠재력을 가지고 있습니다(Helliwell, 2019).</p>
<p>확장된 인지의 개념을 기반으로, 이제 사회적으로 확장된 인지의 아이디어로 눈을 돌립니다. Pritchard(2022)는 협업이 이해에 어떻게 기여하는지 강조함으로써 과학적 지식을 설명합니다. 사회적으로 확장된 인지는 다른 사람들의 정보 처리 활동이 개인의 인지 과정에 통합되어 개인 능력을 넘어선 지식으로 이어질 때 발생합니다. AI가 행위자성을 가지고 있다면, 그것은 우리의 사회적으로 확장된 인지의 일부로 기능할 수 있습니다. AI는 직접적인 가용성이 부족할 수 있는 인간 협업과 달리, 인간과의 협업을 통해 인지 과정을 지원하고 보완합니다. AI는 이러한 제한을 최소화하거나 제거하여 사회적으로 확장된 인지의 형태로서의 역할을 강화합니다. Pritchard는 과학적 지식에 대한 논의를 제한했지만, 저는 그것을 과학적 이해에 관한 연구와 통합하는 것을 목표로 합니다.</p>
<p>이 사회적으로 확장된 인지가 단지 과학적 지식뿐만 아니라 과학적 이해를 어떻게 향상시키는지 파악하기 위해, 우리는 Khalifa의 EKS 모델로 눈을 돌립니다. Khalifa는 과학적 설명적 평가(SEEing)를 통해 얻은 설명적 지식이 이해의 핵심이라고 강조합니다. EKS 모델에서의 SEEing은 타당한 잠재적 설명의 범위를 고려하고 비교한 다음, 증거와 다른 설명적 고려사항에 기반하여 가장 설득력 있는 것을 선택하는 과정입니다. 이 과학적 탐구 과정은 단순한 믿음을 넘어서 우연적이거나 우발적인 요소를 최소화하는 잘 정당화되고 신뢰할 수 있는 이해로 이어집니다. 따라서, AI는 도구로서든 협업 파트너로서든 SEEing을 향상시키는 데 중요한 역할을 합니다.</p>
<p>이 논의를 바탕으로, AI가 과학적 이해에 어떻게 기여하는지에 대한 과학자들의 연구(Krenn 외, 2022)에 대한 비판적 검토는 세 가지 주요 차원을 강조합니다: (1) 계산적 현미경, (2) 영감의 자원, (3) 이해의 에이전트입니다. 데이터 처리 및 평가 도구로서, AI는 연구자들이 잠재적 설명을 비교하고 가장 설득력 있는 것을 식별하는 능력을 향상시킵니다. 협력자로서, AI는 가설을 생성하고, 프레임워크를 정제하고, 인간의 인지를 향상시켜 과학적 평가를 강화합니다. 이러한 두 가지 역할을 통해, AI는 SEEing의 과정을 변형시켜 궁극적으로 향상된 과학적 이해에 기여합니다.</p>
<p><strong>자율무기체계와 정의로운 전쟁 이론: 정전론(Jus in Bello) 원칙에 대한 비판적 재평가</strong></p>
<p>김상수 (육군사관학교)</p>
<p>인공지능(AI)의 혁명적인 발전에 의해 주도되는 자율무기체계(AWS)의 출현은 현대 전쟁을 근본적으로 변화시켜, 정의로운 전쟁 이론(JWT) 프레임워크 내의 정전론(jus in bello) 원칙에 대한 비판적 재평가를 요구합니다. AI 혁신의 산물인 AWS는 독립적으로 작동하여 인간의 개입 없이 중요한 결정을 내림으로써 운영 효율성을 향상시킵니다. 그러나 그들의 자율성은 JWT 하에서 차별과 비례성의 핵심 원칙을 준수할 수 있는 능력에 대한 심각한 윤리적 우려를 제기합니다. 이러한 우려는 AWS가 인간의 생명에 직접적인 영향을 미치는 결정을 포함하는 무기 시스템이라는 점을 고려할 때 특히 중요하며, 그들의 사용을 관리하기 위한 강력한 윤리적 프레임워크의 긴급한 필요성을 강조합니다.</p>
<p>정전론은 전쟁 수행을 규제하는 일련의 윤리적 원칙으로, 전쟁에 관련된 모든 도덕적 행위자가 그 기준을 유지하도록 요구합니다. 국제적 맥락에서 널리 받아들여지는 기본적인 도덕적 지침으로서, 이러한 원칙들은 전쟁의 불가피한 상황에서도 개인의 존엄성과 권리를 보장하기 위한 최소한의 윤리적 프레임워크로 봉사합니다. 특히, 차별과 비례성은 무고한 민간인을 보호하고 무력 사용이 정당한 군사적 목표와 엄격하게 일치하도록 보장함으로써 전쟁의 도덕적 정당성을 유지하는 데 핵심적입니다.</p>
<p>차별의 원칙은 전투원과 비전투원 사이의 명확한 구분을 요구하여, 민간인과 다른 보호 대상을 불필요한 해로부터 보호합니다. 이 원칙은 의사 결정자가 복잡한 전장 시나리오를 평가하고 국제 인도주의법과 일치하는 판단을 내릴 수 있다고 가정합니다. 그럼에도 불구하고, 사전 프로그래밍된 알고리즘과 데이터셋에 의존하는 AWS는 역동적이고 예측 불가능한 환경에서 비전투원을 정확하게 식별하는 데 상당한 도전에 직면합니다. 불완전하거나 편향된 데이터셋이 AWS 의사 결정에 영향을 미칠 때, 차별 원칙의 심각한 위반 위험이 높아집니다.</p>
<p>비례성의 원칙은 군사 행동으로 인한 해악이 예상되는 군사적 이점과 균형을 이루어야 한다고 요구합니다. 이 원칙은 단순한 계산을 넘어서, 도덕적 및 맥락적 요소를 포함하는 미묘한 평가를 요구합니다. 그러나 AWS는 사전 정의된 매개변수에 기반하여 작동하여, 실제 상황의 복잡성을 고려하지 못할 가능성이 있습니다. 예상치 못한 결과의 가능성은 AWS가 실제로 비례성 원칙을 일관되게 유지할 수 있는지에 대한 의문을 더욱 제기합니다.</p>
<p>이 발표는 AWS가 차별과 비례성의 원칙을 효과적으로 준수할 수 있는지를 비판적으로 검토합니다. 전투원과 비전투원을 구별하고, 불법적인 목표를 피하고, 인간의 도덕적 기준에 부합하는 결정을 내리는 AWS의 기술적, 윤리적 능력을 평가합니다. 또한, AWS에 의한 치명적인 힘의 사용이 비례성 원칙 하에서 정당화될 수 있는지 탐구하고, 이러한 윤리적 원칙을 준수하기 위해 인간의 감독이 필요한 정도를 논의합니다.</p>
<p>발표는 세 가지 주요 논의를 중심으로 구성됩니다. 첫째, AWS의 기술적 특성과 운영 역할을 분석하여 JWT의 확립된 원칙과 일치하는지 평가합니다. 둘째, 차별과 비례성의 윤리적, 실질적 해석을 재평가하여 AWS에 적용 가능성을 결정합니다. 셋째, 현대 전쟁에서 AWS와 같은 첨단 기술이 제기하는 윤리적 도전을 반영하도록 정전론 원칙을 재구성하는 대안적 접근법을 제안합니다.</p>
<p>궁극적으로, 이 발표는 AI 혁신에서 기원하고 생명과 죽음의 의미를 가진 AWS를 면밀히 조사하는 윤리적 긴급성을 강조합니다. 정전론의 윤리적 경계 내에서 AWS를 평가하기 위한 프레임워크를 제공하여, 기술적 혁신과 도덕적 책임성의 균형을 맞추는 것을 목표로 합니다. 이 접근법은 정의와 인간성이 진화하는 분쟁의 맥락에서 중심에 남아 있도록 보장하면서 현대 전쟁의 윤리적 기준을 재정의하는 데 기여합니다.</p>
<p><strong>일반 발표 3</strong></p>
<p><strong>예측, 투영, 그리고 수행성</strong></p>
<p>콘스탄틴 제닌 (튀빙겐 대학교)</p>
<p>사회적 맥락에서 예측은 미래 결과에 대한 단순한 인과적으로 무력한 예견이 아니라 예측하려는 결과에 인과적 영향을 미친다는 것이 널리 인식되고 있습니다. 이는 특히 예측이 정책 결정에 직접적으로 영향을 미칠 때 그렇습니다. 예측이 자기 충족적이거나 자기 부정적일 수 있을 때, 실용적 고려사항과 인식론적 고려사항이 얽혀 있고, 정확성의 개념이 모호해집니다. 더욱이, 귀납적 위험의 개념은 재고되어야 합니다: 가치는 다른 종류의 오류의 결과를 고려해야 하기 때문에만 작용하는 것이 아니라, 예측이 잘못된 이유로 옳을 수 있다는 우려 때문에도 작용합니다. 수행성에 대처하는 방법에 대해 많은 제안이 이루어졌으며, 여기에는 수행적 효과를 “내재화”하거나, 사회적으로 바람직한 방향으로 결과를 유도하는 예측을 하는 것 등이 있습니다. 우리는 이러한 접근법이 잘못되었다고 주장합니다. 많은 바람직하지 않은 수행적 효과는 머신러닝 모델의 출력이 어떤 정책이 채택될 것인지 암묵적으로 추측하여 결과를 예측하는 예측과, 어떤 정책 옵션이 선택된다면 결과를 예측하는 반사실적 투영 사이에서 모호하기 때문에 발생합니다. 예측과 투영의 올바른 구별을 하면, 실용적 문제와 인식론적 문제를 깨끗하게 구별할 수 있습니다. 우리는 정확한 투영을 목표로 함으로써만 머신러닝 모델이 의사결정을 지원할 뿐만 아니라 담론을 지원할 수 있다고 주장합니다: 다양한 목표와 가치를 가진 논의자들이 정책 옵션 세트 중 어느 것이 최선의 반성적 타협을 나타내는지에 대한 담론에 참여할 수 있도록 관련 투영을 제공합니다.</p>
<p><strong>블랙 스완 이벤트 예측하기: 머신러닝의 최종 개척지?</strong></p>
<p>허원기 (서울대학교)</p>
<p>블랙 스완 이벤트는 다음 세 가지 주요 특성을 가진 이벤트입니다: (i) 그것은 이상치입니다. (ii) 그것은 극단적인 영향을 미칩니다. (iii) 이벤트 이후, 우리는 그것이 실제보다 덜 무작위적이고 더 예측 가능하게 보이도록 하는 설명(또는 합리적인 이야기)을 만듭니다. 제1차 세계 대전, 소련의 해체, 9/11 테러, 귀납주의자 칠면조의 죽음은 전형적인 예입니다. 그들의 이상치 상태에도 불구하고, 많은 사람들이 블랙 스완 이벤트를 예측하고 싶어합니다. 이는 우리가 이러한 블랙 스완 이벤트를 예측할 수 있다면, 재앙적인 상황으로부터 우리의 삶을 방어할 수 있기 때문입니다. 최근, 일부 머신러닝 연구자들은 블랙 스완 예측 기계를 구축하려고 시도해 왔습니다. 그러나, 이것들은 의미 있는 시도입니까?</p>
<p>이 발표에서, 저는 블랙 스완 예측 기계 구축에 대한 회의적인 논증을 제시할 것입니다. 성공적인 머신 예측을 위해서는 다음 조건들이 충족되어야 합니다: (i) 대량의 고품질 훈련 데이터, (ii) 잘 정의된 예측 작업, (iii) 예측 모델을 평가하기 위한 잘 정의된 대상 벤치마크 또는 특정 기준, (iv) 대상 도메인의 안정적인 배경 조건입니다.</p>
<p>우리가 알다시피, 최근 몇 년 동안 머신러닝 모델은 놀라운 성공을 보여주었습니다(예: 바둑, 이미지 인식, 단백질 구조 예측). 이러한 경우, 머신러닝 모델의 설계와 훈련은 위의 조건을 잘 충족합니다. 그러나, 게임이나 자연 과학 연구와 달리, 희귀한 사회적 이벤트를 예측하는 것은 그러한 조건을 충족하기 어렵기 때문에 어렵습니다.</p>
<p>첫째, 블랙 스완 이벤트는 매우 희귀하여, 패턴을 발견하기 위한 충분히 크고 고품질의 데이터셋을 준비하기 어렵습니다. 둘째, 예측 작업 자체를 정의하는 것이 어렵습니다. 예를 들어, 5년 내에 세계 인구의 5%가 사망하는 이벤트로 정의해야 할까요? 아니면 1조 달러의 손실을 초래하는 이벤트로 정의해야 할까요? 마찬가지로, 예측 모델을 평가하기 위한 기준을 설정하기도 어렵습니다. 가장 중요하게는, 우리의 사회적 환경이 끊임없이 변화하고 있기 때문에, 성공적인 블랙 스완 예측 모델이 미래에도 효과적으로 유지될 가능성이 낮습니다.</p>
<p>환경 변화 외에도, 우리는 예측에 기반하여 행동을 조정하는데, 이는 소위 “준비성 역설”을 도입합니다. 블랙 스완 이벤트를 예측하면, 우리는 그것의 발생을 방지하기 위한 조치를 취할 것입니다. 이러한 조치가 성공적이라면, 블랙 스완 이벤트는 발생하지 않을 것입니다. 문제는 이 경우, 우리의 예측이나 치료를 테스트할 수 있는 쌍둥이 지구와 같은 것이 없기 때문에 예측 모델이 유용했는지 여부를 결정할 수 없다는 것입니다.</p>
<p>결론적으로, 블랙 스완 예측 모델을 구축하는 것은 매우 어려울 뿐만 아니라, 만약 성공하더라도 평가하기 어렵습니다.</p>
<p><strong>일반 발표 4</strong></p>
<p><strong>불투명성을 넘어서: ML 모델 이해에 있어 구현 세부사항이 중요한 이유</strong></p>
<p>이형석 (서울대학교)</p>
<p>과학자들은 현상을 파악하고 정당화하기 위해 가설, 이론, 모델에 의존합니다. 반면에, 인간 인지 능력의 한계를 보완하기 위해 도입된 머신러닝(ML) 모델은 이론, 법칙, 메커니즘, 또는 과학적 모델에 의존하지 않습니다. 대신, ML 모델은 훈련을 위해 제공된 입력과 출력 데이터 사이의 올바른 대응을 나타내는 데이터 모델을 찾습니다. 결과적으로, ML에 의해 생성된 데이터 중심 모델은 대부분 불투명하고 인간이 이해하기 어렵습니다.</p>
<p>이러한 상황에서, 과학자들이 예측이나 추론을 위해 불투명하고 이해하기 어려운 ML 모델을 점점 더 채택한다면 설명과 이해의 과학적 가치가 훼손될 것이라는 우려가 있습니다. 과학적 목적을 위한 ML 사용이 꾸준히 증가함에 따라, ML이 생성한 예측 결과를 이해하고 설명할 수 없는 것은 과학의 목표가 설명에서 단순한 예측으로 이동하고 있는지에 대한 의문을 제기합니다.</p>
<p>이에 대응하여, Sullivan(2022)은 ML 모델을 사용할 때 우리의 과학적 이해가 제한되는 현상에 대한 부적절한 진단으로 인해 우리가 불필요하게 걱정하고 있다고 주장합니다. ML 모델의 불투명성은 우리의 이해를 해치지 않습니다; 그녀가 주장하는 실제 문제는 ML 모델과 현상을 연결하는 과학적 증거의 부족입니다. 그녀는 실제 세계의 설명과 이해를 촉진하기 위해서는 모델과 현상을 연결하는 증거를 확보해야 하며, 모델의 내부 구현 상태에 대해 더 많이 아는 것이 세계에 대한 우리의 이해를 증가시키지 않는다고 주장합니다.</p>
<p>저는 구현 불투명성이 ML 모델의 이해를 방해하지 않는다는 Sullivan의 주장이 잘못되었다고 생각합니다. 그녀는 단지 가혹한 현실에서 고개를 돌렸을 뿐입니다. 구현 불투명성을 해결하지 않고는 ML 모델의 예측을 이해할 수 없습니다.</p>
<p>첫째, 저는 Sullivan이 제공한 세 가지 예(Schelling의 분리 모델, 흑색종 감지 모델, 성적 지향 예측 모델)를 분석하여 그녀가 말하는 “링크 불확실성”이 무엇을 의미하는지 명확히 할 것입니다. 이 분석은 Sullivan이 설명하는 모델과 현상 사이의 연결이 두 단계를 통해 형성된다는 것을 보여줄 것입니다: 첫째, ML 모델을 인간이 인식할 수 있는 대리 모델로 대체하고, 둘째, 이 대리 모델을 현상을 나타내는 전통적인 과학적 모델에 연결하는 것입니다. 다음으로, 저는 ML 모델의 구현 과정을 파악하지 못하면, 충분히 발전된 xAI 기술을 사용하여 ML 모델을 인간이 인식할 수 있는 대리 모델로 대체함으로써 연결의 첫 번째 단계가 달성되더라도, 두 번째 단계의 성공이 매우 불안정할 수 있음을 보여줄 것입니다. 결과적으로, 저는 구현 불투명성을 해결하지 않고도 ML 모델을 통해 과학적 이해를 얻을 수 있다는 Sullivan의 주장이 받아들일 수 없다고 주장합니다. 왜냐하면 구현 불투명성을 해결하지 않고는 링크 불확실성을 해결할 수 없기 때문입니다.</p>
<p><strong>AI는 과학적 지식의 경로가 될 수 있는가?</strong></p>
<p>니콜라이 장 리 린딩 페더슨 (연세대학교)</p>
<p>옌스 크리스티안 비예링 (오르후스 대학교)</p>
<p>인공지능은 데이터를 수집, 분석, 해석하는 방식을 재형성하며 과학적 지식을 추구하는 데 있어 변혁적인 도구로서 점점 더 자리매김하고 있습니다. 그러나 어떤 조건 하에서 AI 시스템이 과학적 지식을 생산할 수 있을까요?</p>
<p>지식에는 신뢰성이 요구됩니다(여기서는 그렇게 가정할 것입니다). 진실된 믿음은 신뢰할 수 있는 믿음 형성 방법이나 과정(즉, 대부분 참된 믿음을 생성하는 것)을 통해 형성된 경우에만 지식으로 자격을 갖습니다. 따라서, 진실된 AI 기반 과학적 믿음은 신뢰할 수 있는 AI 방법이나 믿음 형성 과정(즉, AI 결과를 입력으로 취하고 믿음을 출력으로 전달하는 방법이나 과정)을 통해 형성된 경우에만 지식으로 자격을 갖습니다. 우리는 신뢰성이 AI 기반 지식의 필요 조건일 수 있지만, 진실과 함께 충분하지 않다고 주장합니다. 신뢰성은 관련 AI 믿음 형성 방법이나 과정이 매우 부정확한 입력을 취하지 않도록 보장하는 조건으로 보완되어야 합니다.</p>
<p>우리는 AI 시스템이 만들 수 있는 오류의 특징적 성격에 대한 고려를 통해 이 조건에 집중합니다. AI 시스템은 때때로 “미친” 또는 “놀라운” 오류를 범할 수 있습니다 - 예를 들어, 새를 자동차로 분류하는 것과 같은 오류입니다. 이러한 종류의 오류는 인간이 일반적으로 범하는 오류와 질적으로 다른 것으로 보입니다. 그것들은 단순히 사소한 부정확성을 반영하는 것이 아니라 처리되는 데이터와 연결되지 않은 것처럼 보이는 극단적인 실패를 드러냅니다.</p>
<p>이런 잘못된 AI 생성 결과를 입력으로 취하는 방법이나 과정을 통해 믿음을 형성하는 것은 지식의 전망을 훼손하기 때문에 인식론적으로 위험합니다. 이 점은 두 수준의 인식론적 평가를 특징으로 하는 프레임워크 내에서 명확히 되고 주장됩니다: 방법이나 과정의 믿음 출력의 인식론적 가치와 그 입력의 정확성입니다. 인식론적 가치는 삼분법적입니다. 세 가지 인식론적 가치가 있습니다: 진실, 거짓, 그리고 지식입니다. 정확성은 단위 간격, 즉 [0; 1]의 실수 값을 취합니다.</p>
<p>믿음 형성 방법과 과정이 고도로 부정확한 입력을 취하지 않아야 한다는 조건은 최대최소 스타일의 조건입니다. 입력의 최소 정확성이 너무 낮지 않아야 합니다. 이 조건을 충족하지 못한다는 것은 때때로 고도로 부정확한 입력을 취하는 방법이나 과정을 통해 믿음을 형성한다는 것을 의미합니다. 이는 지식과 양립할 수 없기 때문에 인식론적으로 위험합니다. 따라서, 고도로 부정확한 입력은 지식의 전망을 훼손합니다.</p>
<p>우리는 높은 부정확성과 지식 사이의 연결에 대해 다음과 같은 진단을 제공합니다: 소스 S로부터의 출력을 입력으로 취하는 믿음 형성 방법이나 과정의 경우, S의 일부 출력이 극도로 부정확하다면 S의 역량이 훼손됩니다. 그러나, 소스가 역량을 갖추지 못한다는 것은 그것의 전달에 기반하여 믿음을 형성하는 것이 대부분 참된 믿음으로 이어진다 하더라도 지식의 기초로 기능할 수 없다는 것을 의미합니다. 따라서, 때때로 고도로 부정확한 출력을 제공하는 AI 시스템은 그들의 출력에 기반하여 형성된 대부분의 믿음이 참이라고 하더라도 지식의 기초로 기능할 수 없습니다. 이는 그러한 AI 시스템이 역량을 보여주지 못하기 때문입니다.</p>
<p><a href="https://25swpml.wordpress.com/program/">프로그램</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/transdocs\.modellings\.art");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../documents/Program.html" class="pagination-link" aria-label="2025 Seoul Workshop on Philosophy of Machine Learning">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">2025 Seoul Workshop on Philosophy of Machine Learning</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../extracted/Probably Overthinking It.html" class="pagination-link" aria-label="PROBABLY OVERTHINKING IT">
        <span class="nav-page-text">PROBABLY OVERTHINKING IT</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>This work © 2024 by Sungkyun Cho is licensed under CC BY-NC-SA 4.0</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>